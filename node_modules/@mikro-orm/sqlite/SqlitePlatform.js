"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlitePlatform = void 0;
// @ts-ignore
const sqlstring_sqlite_1 = require("sqlstring-sqlite");
const core_1 = require("@mikro-orm/core");
const knex_1 = require("@mikro-orm/knex");
const SqliteSchemaHelper_1 = require("./SqliteSchemaHelper");
const SqliteExceptionConverter_1 = require("./SqliteExceptionConverter");
class SqlitePlatform extends knex_1.AbstractSqlPlatform {
    constructor() {
        super(...arguments);
        this.schemaHelper = new SqliteSchemaHelper_1.SqliteSchemaHelper();
        this.exceptionConverter = new SqliteExceptionConverter_1.SqliteExceptionConverter();
    }
    requiresNullableForAlteringColumn() {
        return true;
    }
    usesDefaultKeyword() {
        return false;
    }
    getCurrentTimestampSQL(length) {
        return super.getCurrentTimestampSQL(0);
    }
    convertsJsonAutomatically() {
        return false;
    }
    allowsComparingTuples() {
        return false;
    }
    /**
     * This is used to narrow the value of Date properties as they will be stored as timestamps in sqlite.
     * We use this method to convert Dates to timestamps when computing the changeset, so we have the right
     * data type in the payload as well as in original entity data. Without that, we would end up with diffs
     * including all Date properties, as we would be comparing Date object with timestamp.
     */
    processDateProperty(value) {
        if (value instanceof Date) {
            return +value;
        }
        return value;
    }
    quoteVersionValue(value, prop) {
        if (prop.type.toLowerCase() === 'date') {
            return sqlstring_sqlite_1.escape(value, true, this.timezone).replace(/^'|\.\d{3}'$/g, '');
        }
        return value;
    }
    requiresValuesKeyword() {
        return true;
    }
    quoteValue(value) {
        /* istanbul ignore if */
        if (core_1.Utils.isPlainObject(value)) {
            return sqlstring_sqlite_1.escape(JSON.stringify(value), true, this.timezone);
        }
        if (value instanceof Date) {
            return '' + +value;
        }
        return sqlstring_sqlite_1.escape(value, true, this.timezone);
    }
}
exports.SqlitePlatform = SqlitePlatform;
